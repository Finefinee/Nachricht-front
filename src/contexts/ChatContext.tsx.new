import React, { createContext, useReducer, useEffect, useCallback, useState } from 'react';
import type { ChatState, MessengerRoom, MessageEntity, SendMessageRequest } from '../types';
import { roomAPI, messageAPI } from '../services/api';
import webSocketService from '../services/websocket';
import { useAuth } from '../hooks/useAuth';

interface ChatAction {
  type: 
    | 'SET_LOADING'
    | 'SET_ERROR'
    | 'SET_ROOMS'
    | 'SET_MESSAGES'
    | 'ADD_MESSAGE'
    | 'SET_ACTIVE_ROOM'
    | 'CLEAR_ERROR';
  payload?: unknown;
}

const initialState: ChatState = {
  rooms: [],
  messages: {},
  activeRoom: null,
  isLoading: false,
  error: null,
};

const chatReducer = (state: ChatState, action: ChatAction): ChatState => {
  switch (action.type) {
    case 'SET_LOADING': {
      return {
        ...state,
        isLoading: action.payload as boolean,
      };
    }
    case 'SET_ERROR': {
      return {
        ...state,
        error: action.payload as string,
        isLoading: false,
      };
    }
    case 'SET_ROOMS': {
      return {
        ...state,
        rooms: action.payload as MessengerRoom[],
        isLoading: false,
      };
    }
    case 'SET_MESSAGES': {
      const { roomId, messages } = action.payload as { roomId: number; messages: MessageEntity[] };
      return {
        ...state,
        messages: {
          ...state.messages,
          [roomId]: messages,
        },
        isLoading: false,
      };
    }
    case 'ADD_MESSAGE': {
      const message = action.payload as SendMessageRequest;
      const roomId = message.roomId;
      const currentMessages = state.messages[roomId] || [];
      
      // ì¤‘ë³µ ë©”ì‹œì§€ ë°©ì§€
      const isDuplicate = currentMessages.some(
        (msg) => msg.content === message.content && 
                 msg.sender.username === message.senderUsername &&
                 Math.abs(new Date(msg.sentAt).getTime() - new Date(message.when).getTime()) < 1000
      );
      
      if (!isDuplicate) {
        // SendMessageRequestë¥¼ MessageEntity í˜•íƒœë¡œ ë³€í™˜
        const messageEntity: MessageEntity = {
          id: Date.now(), // ìž„ì‹œ ID
          content: message.content,
          sentAt: message.when,
          sender: { username: message.senderUsername, role: 'USER' },
          room: state.rooms.find(r => r.id === roomId) || { id: roomId, participants: [] },
        };
        
        return {
          ...state,
          messages: {
            ...state.messages,
            [roomId]: [...currentMessages, messageEntity],
          },
        };
      }
      return state;
    }
    case 'SET_ACTIVE_ROOM': {
      return {
        ...state,
        activeRoom: action.payload as MessengerRoom,
      };
    }
    case 'CLEAR_ERROR': {
      return {
        ...state,
        error: null,
      };
    }
    default:
      return state;
  }
};

interface ChatContextType {
  state: ChatState;
  loadRooms: () => Promise<void>;
  loadMessages: (roomId: number) => Promise<void>;
  sendMessage: (roomId: number, content: string) => void;
  setActiveRoom: (room: MessengerRoom) => void;
  createRoom: (participantUsername: string) => Promise<MessengerRoom | null>;
  clearError: () => void;
  isInitializing: boolean;
}

export const ChatContext = createContext<ChatContextType | undefined>(undefined);

export const ChatProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(chatReducer, initialState);
  const { state: authState } = useAuth();
  const [isInitializing, setIsInitializing] = useState(true);

  useEffect(() => {
    // WebSocket ë©”ì‹œì§€ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    const unsubscribeMessage = webSocketService.onMessage((message: SendMessageRequest) => {
      dispatch({ type: 'ADD_MESSAGE', payload: message });
    });

    return () => {
      unsubscribeMessage();
    };
  }, []);

  const loadRooms = useCallback(async () => {
    if (!authState.user) {
      console.warn('ðŸš« ì‚¬ìš©ìž ì •ë³´ê°€ ì—†ì–´ ì±„íŒ…ë°©ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    console.log(`ðŸ“‚ ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ ì‹œìž‘ - ì‚¬ìš©ìž: ${authState.user.username}`);
    dispatch({ type: 'SET_LOADING', payload: true });
    
    try {
      const rooms = await roomAPI.getUserRooms(authState.user.username);
      
      console.log('ðŸ“¦ ë°±ì—”ë“œ ì‘ë‹µ ì›ë³¸ ë°ì´í„°:', JSON.stringify(rooms, null, 2));
      console.log(`âœ… ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ ì„±ê³µ - ${rooms.length}ê°œ ì±„íŒ…ë°©:`, 
        rooms.map(r => ({ id: r.id, participants: r.participants?.map(p => p.username) || 'ë°ì´í„° ì—†ìŒ' })));
      
      // ì‘ë‹µ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
      const validatedRooms = rooms.map(room => {
        // í•„ìˆ˜ í•„ë“œ í™•ì¸ ë° ì„¤ì •
        if (!room.participants || !Array.isArray(room.participants)) {
          console.warn(`âš ï¸ ì±„íŒ…ë°© #${room.id}ì˜ participants í•„ë“œê°€ ì—†ê±°ë‚˜ ë°°ì—´ì´ ì•„ë‹™ë‹ˆë‹¤:`, room);
          room.participants = []; // ì•ˆì „í•œ ê¸°ë³¸ê°’ ì„¤ì •
        }
        return room;
      });
      
      console.log('ðŸ” ê°€ê³µëœ ì±„íŒ…ë°© ë°ì´í„°:', validatedRooms);
      dispatch({ type: 'SET_ROOMS', payload: validatedRooms });
      
      return validatedRooms;
    } catch (error) {
      console.error('âŒ ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', error);
      dispatch({ 
        type: 'SET_ERROR', 
        payload: 'ì±„íŒ…ë°© ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ì„ ì‹œë„í•´ë³´ì„¸ìš”.' 
      });
      return [];
    }
  }, [authState.user]);
  
  // ë™ê¸°ì‹ ì´ˆê¸°í™” í•¨ìˆ˜ - ëª¨ë“  ë°ì´í„° ë¡œë“œê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
  const initializeApp = useCallback(async () => {
    if (!authState.isAuthenticated || !authState.user) {
      setIsInitializing(false);
      return;
    }
    
    console.log('ðŸ”„ ì±„íŒ… ì•± ë™ê¸°ì‹ ì´ˆê¸°í™” ì‹œìž‘');
    setIsInitializing(true);
    dispatch({ type: 'SET_LOADING', payload: true });
    
    try {
      // 1. ì›¹ì†Œì¼“ ì—°ê²° ì„¤ì • - ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
      console.log('ðŸ”Œ ì›¹ì†Œì¼“ ì—°ê²° ì‹œë„...');
      await webSocketService.connect(authState.user.username);
      console.log('âœ… ì›¹ì†Œì¼“ ì—°ê²° ì„±ê³µ');
      
      // 2. ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ - ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
      console.log('ðŸ“ ì±„íŒ…ë°© ëª©ë¡ ë¡œë“œ ì‹œìž‘');
      const rooms = await loadRooms();
      console.log(`âœ… ì±„íŒ…ë°© ${rooms.length}ê°œ ë¡œë“œ ì™„ë£Œ`);
      
      // 3. ì²« ë²ˆì§¸ ì±„íŒ…ë°©ì´ ìžˆìœ¼ë©´ ë©”ì‹œì§€ ë¡œë“œ - ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
      if (rooms.length > 0) {
        const firstRoom = rooms[0];
        console.log(`ðŸ“© ì²« ë²ˆì§¸ ì±„íŒ…ë°©(ID: ${firstRoom.id}) ë©”ì‹œì§€ ë¡œë“œ ì‹œìž‘`);
        
        dispatch({ type: 'SET_ACTIVE_ROOM', payload: firstRoom });
        await loadMessages(firstRoom.id);
        
        console.log('âœ… ì²« ë²ˆì§¸ ì±„íŒ…ë°© ë©”ì‹œì§€ ë¡œë“œ ì™„ë£Œ');
      } else {
        console.log('â„¹ï¸ ë¡œë“œí•  ì±„íŒ…ë°©ì´ ì—†ìŠµë‹ˆë‹¤');
      }
      
      console.log('âœ…âœ… ì•± ì´ˆê¸°í™” ì™„ë£Œ - ëª¨ë“  ë°ì´í„° ë¡œë“œë¨');
    } catch (error) {
      console.error('âŒ ì•± ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜:', error);
      dispatch({ 
        type: 'SET_ERROR',
        payload: 'ì•± ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'
      });
    } finally {
      setIsInitializing(false);
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [authState.isAuthenticated, authState.user, loadRooms, loadMessages]);

  useEffect(() => {
    // ì¸ì¦ ìƒíƒœê°€ ë³€ê²½ë˜ë©´ ë™ê¸°ì‹ìœ¼ë¡œ ì•± ì´ˆê¸°í™”
    initializeApp();
  }, [authState.isAuthenticated, authState.user, initializeApp]);

  const loadMessages = async (roomId: number) => {
    dispatch({ type: 'SET_LOADING', payload: true });
    try {
      console.log(`ðŸ“© ì±„íŒ…ë°© #${roomId} ë©”ì‹œì§€ ë¡œë“œ ì‹œìž‘`);
      const messages = await messageAPI.getMessages(roomId);
      console.log(`âœ… ì±„íŒ…ë°© #${roomId} ë©”ì‹œì§€ ${messages.length}ê°œ ë¡œë“œ ì™„ë£Œ`);
      
      dispatch({ type: 'SET_MESSAGES', payload: { roomId, messages } });
      return messages;
    } catch (error) {
      console.error(`âŒ ì±„íŒ…ë°© #${roomId} ë©”ì‹œì§€ ë¡œë“œ ì‹¤íŒ¨:`, error);
      dispatch({ 
        type: 'SET_ERROR', 
        payload: 'ë©”ì‹œì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' 
      });
      return [];
    }
  };

  const sendMessage = (roomId: number, content: string) => {
    if (!authState.user || !content.trim()) return;

    const message: SendMessageRequest = {
      senderUsername: authState.user.username,
      roomId,
      content: content.trim(),
      when: new Date().toLocaleTimeString(),
    };

    // WebSocketìœ¼ë¡œ ë©”ì‹œì§€ ì „ì†¡
    webSocketService.sendMessage(message);
    
    // ì¦‰ì‹œ UIì— ë°˜ì˜ (ë‚™ê´€ì  ì—…ë°ì´íŠ¸)
    dispatch({ type: 'ADD_MESSAGE', payload: message });
  };

  const setActiveRoom = (room: MessengerRoom) => {
    dispatch({ type: 'SET_ACTIVE_ROOM', payload: room });
    loadMessages(room.id);
  };

  const createRoom = async (participantUsername: string): Promise<MessengerRoom | null> => {
    if (!authState.user) return null;

    try {
      // roomAPIëŠ” string[] íƒ€ìž…ì„ ê¸°ëŒ€í•©ë‹ˆë‹¤
      const room = await roomAPI.createRoom([authState.user.username, participantUsername]);
      
      // ìƒˆ ì±„íŒ…ë°©ì„ ëª©ë¡ì— ì¶”ê°€
      dispatch({ type: 'SET_ROOMS', payload: [...state.rooms, room] });
      return room;
    } catch (error) {
      console.error('âŒ ì±„íŒ…ë°© ìƒì„± ì‹¤íŒ¨:', error);
      dispatch({ 
        type: 'SET_ERROR', 
        payload: 'ì±„íŒ…ë°© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' 
      });
      return null;
    }
  };

  const clearError = () => {
    dispatch({ type: 'CLEAR_ERROR' });
  };

  return (
    <ChatContext.Provider value={{ 
      state, 
      loadRooms, 
      loadMessages, 
      sendMessage, 
      setActiveRoom, 
      createRoom,
      clearError,
      isInitializing
    }}>
      {children}
    </ChatContext.Provider>
  );
};
